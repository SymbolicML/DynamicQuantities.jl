var documenterSearchIndex = {"docs":
[{"location":"index_base/","page":"DynamicUnits","title":"DynamicUnits","text":"CurrentModule = DynamicUnits","category":"page"},{"location":"index_base/#DynamicUnits","page":"DynamicUnits","title":"DynamicUnits","text":"","category":"section"},{"location":"index_base/","page":"DynamicUnits","title":"DynamicUnits","text":"Documentation for DynamicUnits.","category":"page"},{"location":"index_base/","page":"DynamicUnits","title":"DynamicUnits","text":"","category":"page"},{"location":"index_base/","page":"DynamicUnits","title":"DynamicUnits","text":"Modules = [DynamicUnits]","category":"page"},{"location":"#DynamicUnits","page":"Home","title":"DynamicUnits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This defines a simple statically-typed Quantity type for Julia. Physical dimensions are stored as a value, as opposed to a parametric type, as in Unitful.jl. This is done to allow for calculations where physical dimensions are not known at compile time.","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The performance of DynamicUnits is slower than Unitful if the dimensions are known at compile time:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using BenchmarkTools\n\njulia> dyn_uni = Quantity(0.2, mass=1, length=0.5, amount=3)\n0.2 ğ‹^(1//2) ğŒ^1 ğ^3\n\njulia> unitful = convert(Unitful.Quantity, dyn_uni)\n0.2 kg mÂ¹áŸÂ² molÂ³\n\njulia> f(x) = x ^ 2 * 0.3;\n\njulia> @btime f($dyn_uni);\n  56.317 ns (0 allocations: 0 bytes)\n\njulia> @btime f($unitful);\n  1.958 ns (0 allocations: 0 bytes)","category":"page"},{"location":"","page":"Home","title":"Home","text":"While both of these are type stable, because Unitful parametrizes the type on the dimensions, functions can specialize to units and the compiler can optimize away units from the code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"However, if the dimension is unknown, the performance can suffer quite a bit. This is where DynamicUnits shines:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> g(x) = x ^ rand(1:10) * 0.3;\n\njulia> @btime g($dyn_uni);\n  80.449 ns (0 allocations: 0 bytes)\n\njulia> @btime g($unitful);\n  29.666 Î¼s (42 allocations: 1.91 KiB)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here, only the DynamicUnits Quantity results in a function that is type stable, while the Unitful Quantity results in the compiler having to do type inference at runtime.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can create a Quantity object with a value and keyword arguments for the powers of the physical dimensions (mass, length, time, current, temperature, luminosity, amount):","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x = Quantity(0.2, mass=1, length=0.5)\n0.2 ğ‹^(1//2) ğŒ^1\n\njulia> y = Quantity(10.2, mass=2, time=-2)\n10.2 ğŒ^2 ğ“^(-2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Elementary calculations with +, -, *, /, ^, sqrt, cbrt are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x * y\n2.04 ğ‹^(1//2) ğŒ^3 ğ“^(-2)\n\njulia> x / y\n0.019607843137254905 ğ‹^(1//2) ğŒ^(-1) ğ“^2\n\njulia> x ^ 3\n0.008000000000000002 ğ‹^(3//2) ğŒ^3\n\njulia> x ^ -1\n5.0 ğ‹^(-1//2) ğŒ^(-1)\n\njulia> sqrt(x)\n0.4472135954999579 ğ‹^(1//4) ğŒ^(1//2)\n\njulia> x ^ 1.5\n0.0894427190999916 ğ‹^(3//4) ğŒ^(3//2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Each of these values has the same type, thus obviating the need for type inference at runtime.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, we can do dimensional analysis automatically:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> x + 3 * x\n0.8 ğ‹^(1//2) ğŒ^1\n\njulia> x + y\nINVALID","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can see the second one has valid(quantity) == false. This doesn't throw an error by default, as it allows for stable return values.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The dimensions of a Quantity can be accessed either with dimension(quantity) for the entire Dimensions object:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> dimension(x)\nğ‹^(1//2) ğŒ^1","category":"page"},{"location":"","page":"Home","title":"Home","text":"or with umass, ulength, etc., for the various dimensions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> umass(x)\n1//1\n\njulia> ulength(x)\n1//2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, you can strip units with ustrip:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ustrip(x)\n0.2","category":"page"},{"location":"#Units","page":"Home","title":"Units","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Despite the name, DynamicUnits does not actually work with units. Instead, it works with dimensions. You can use Unitful to parse units, and use the DynamicUnits->Unitful extension for conversion:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Unitful: Unitful, @u_str\n\njulia> x = 0.5u\"km/s\"\n0.5 km sâ»Â¹\n\njulia> y = convert(DynamicUnits.Quantity, x)\n500.0 ğ‹^1 ğ“^(-1)\n\njulia> y2 = y^2 * 0.3\n75000.0 ğ‹^2 ğ“^(-2)\n\njulia> x2 = convert(Unitful.Quantity, y2)\n75000.0 mÂ² sâ»Â²\n\njulia> x^2*0.3 == x2\ntrue","category":"page"},{"location":"#Vectors","page":"Home","title":"Vectors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There is not a separate class for vectors, but you can create units like so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> randn(5) .* Dimensions(mass=2/5, length=2)\n5-element Vector{Quantity{Float64}}:\n -0.72119725412798 ğ‹^2 ğŒ^(2//5)\n 0.6443068291470538 ğ‹^2 ğŒ^(2//5)\n 1.2137320667123697 ğ‹^2 ğŒ^(2//5)\n 0.5125746727860678 ğ‹^2 ğŒ^(2//5)\n -0.6511788444561991 ğ‹^2 ğŒ^(2//5)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because it is type stable, you can have mixed units in a vector too:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> v = [Quantity(randn(), mass=rand(0:5), length=rand(0:5)) for _=1:5]\n5-element Vector{Quantity{Float64}}:\n 0.6531745868307951 \n 0.5260730397041357 ğ‹^2 ğŒ^5\n 1.0827471975303913 ğŒ^1\n 1.5524518860763528 ğŒ^1\n 0.5376635007504901 ğ‹^3 ğŒ^1","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DynamicUnits","category":"page"},{"location":"#DynamicUnits-2","page":"Home","title":"DynamicUnits","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DynamicUnits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DynamicUnits]","category":"page"}]
}
